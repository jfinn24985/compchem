class compound
!!!1383721.cpp!!!	add_child(in a_name : string, in a_label : string) : basic_datum
basic_datum * Result (NULL);
if (data_access::names::formula_name () == a_name)
{
  Result = &(add_formula (a_label));
}
else if (data_access::names::identity_name () == a_name)
{
  Result = &(add_identity (a_label));
}
else if (data_access::names::info_name () == a_name)
{
  Result = &(add_info (a_label));
}
else
{
  const bool bad_child_name (false);
  COMPCHEM_ALWAYS (bad_child_name, serial_name() + " class has no child with name " + a_name);
}
return *Result;
!!!1182889.cpp!!!	add_formula(in a_label : string) : formula
// LOCAL
m_instances.push_back (new formula (*this, a_label));
// formulae are always last
append_child (m_instances.back ());
return m_instances.back ();
!!!1383593.cpp!!!	add_identity(in a_label : string) : identity
// LOCAL
// Create new object.
m_identity.push_back (new identity (*this, a_label));
// Insert: Identity is first elements.
if (has_information ())
{
  insert_child (*(m_info.get ()), m_identity.back ());
}
else if (not m_instances.empty ())
{
  insert_child (m_instances.front (), m_identity.back ());
}
else
{
  append_child (m_identity.back ());
}
return m_identity.back ();
!!!1113129.cpp!!!	add_info(in a_label : string) : info
// To set a node we check if node exists, and replace if not equal OR we insert in the right place.
m_info.reset (new info (*this, a_label));
// Insert: Info is before formula elements.
if (not m_instances.empty ())
{
  insert_child (m_instances.front (), *(m_info.get ()));
}
else
{
  append_child (*(m_info.get ()));
}
return *(m_info.get ());
!!!1501737.cpp!!!	find_formula(in a_label : string) : formula_iterator
return std::find_if (begin_formula (), end_formula ()
    , boost::bind (std::equal_to< std::string >(), boost::bind (&formula::label, _1), a_label));
!!!1659689.cpp!!!	find_formula(in a_label : string) : const_formula_iterator
return std::find_if (begin_formula (), end_formula ()
    , boost::bind (std::equal_to< std::string >(), boost::bind (&formula::label, _1), a_label));
!!!1384233.cpp!!!	get_attribute(in a_name : string, out a_value : string) : bool
REQUIRE (not label ().empty (), "Attempting to write an invalid compound object.");
bool Result (false);
// Process attributes.
if (a_name == data_access::names::label_name ())
{
  a_value.assign (m_label);
  Result = true;
}
else if (a_name == data_access::names::category_name ())
{
  if (not m_categories.empty ())
  {
    a_value.assign (m_categories);
    Result = true;
  }
}
return Result;
!!!1384105.cpp!!!	set_attribute(in a_name : string, in a_value : string) : void
if (data_access::names::category_name () == a_name) 
{
  m_categories.swap (a_value);
}
else if (data_access::names::label_name () == a_name) 
{
  COMPCHEM_ALWAYS (a_value == label (), serial_name () + " object labels cannot be changed after construction");
}
else
{
  const bool bad_attribute_name (false);
  COMPCHEM_ALWAYS (bad_attribute_name, serial_name () + " objects do not have an attribute named " + a_name);
}

!!!1662505.cpp!!!	virt_remove_child(inout a_datum : basic_datum) : void
// formula*, identity* or info?
COMPCHEM_ALWAYS (not empty_formula () or not empty_identity () or has_information ()
                 , "attempt to remove non-child object");
// a_datum should be an info object!
struct helper__
{
  static bool compare_ptr1 (formula &a_iter, basic_datum* a_item)
  {
    return &(a_iter) == a_item;
  }
  static bool compare_ptr2 (identity &a_iter, basic_datum* a_item)
  {
    return &(a_iter) == a_item;
  }
};
if (m_info.get () == a_datum)
{
  m_info.reset ();
}
else
{
  formula_iterator l_f (std::find_if (begin_formula (), end_formula (), boost::bind(helper__::compare_ptr1, _1, a_datum)));
  if (l_f != end_formula ())
  {
    m_instances.erase (l_f);
  }
  else
  {
    identity_iterator l_i (std::find_if (begin_identity (), end_identity (), boost::bind(helper__::compare_ptr2, _1, a_datum)));
    COMPCHEM_ALWAYS (l_i != end_identity (), "attempt to remove non-child object");
    m_identity.erase (l_i);
  }
}
