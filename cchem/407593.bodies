class matcher_filter
!!!1541161.cpp!!!	make_matcher(in a_line : string) : basic_matcher
// Helper class to provide two internal conversion functions.
class helper__
{
public:
  static int convert_type (std::string a_type)
  {
    COMPCHEM_ALWAYS (not a_type.empty (), "Invalid matcher phrase with no type");
    boost::to_lower (a_type); // Convert to lower case
    int Result (-1);
    if ("byte" == a_type) Result = 0;
    else if ("line" == a_type) Result = 1;
    else if ("string" == a_type) Result = 2;
    else if ("regex" == a_type) Result = 3;
    COMPCHEM_ALWAYS (Result != -1, "Invalid matcher type \"" + a_type +  "\", can be 'byte', 'line', 'string' or 'regex'");
    return Result;
  }
  static int convert_mode (std::string a_mode)
  {
    COMPCHEM_ALWAYS (not a_mode.empty (), "Invalid matcher phrase with no type");
    boost::to_lower (a_mode); // Convert to lower case
    int Result (-1);
    if ("first" == a_mode) Result = 0;
    else if ("last" == a_mode) Result = 1;
    else if ("accum" == a_mode) Result = 2;
    COMPCHEM_ALWAYS (Result != -1, "Invalid matcher mode \"" + a_mode +  "\", can be 'first', 'last' or 'accum'");
    return Result;
  }
};
//////////////////////
// Split the content into tokens and process
std::auto_ptr< basic_matcher > Result;
boost::tokenizer < boost::escaped_list_separator < char > > l_defn_tokenizer (a_line);
boost::tokenizer < boost::escaped_list_separator < char > >::iterator l_defn_iter (l_defn_tokenizer.begin ());
COMPCHEM_ALWAYS (l_defn_iter != l_defn_tokenizer.end () and not l_defn_iter->empty (), "Invalid filter definition, is empty or has no type text.");
// First element should be a type.
// 'byte'|'lines'|'string'|'regex'

switch (helper__::convert_type (*l_defn_iter))
{
case 0:
  {
    // Byte matcher. Next element should be a number
    ++l_defn_iter;
    COMPCHEM_ALWAYS (l_defn_iter != l_defn_tokenizer.end (), "Invalid filter 'byte' definition with byte count");
    unsigned int l_count (boost::lexical_cast< unsigned int >(*l_defn_iter));
    Result.reset (new matcher_bytes (l_count));
  }
  break;
case 1:
  {
    // Byte matcher. Next element should be a number
    ++l_defn_iter;
    COMPCHEM_ALWAYS (l_defn_iter != l_defn_tokenizer.end (), "Invalid filter 'line' definition with line count");
    unsigned int l_count (boost::lexical_cast< unsigned int >(*l_defn_iter));
    Result.reset (new matcher_lines (l_count));
  }
case 2:
  {
    // Have a string matcher
    std::string l_match;
    ++l_defn_iter;
    COMPCHEM_ALWAYS (l_defn_iter != l_defn_tokenizer.end (), "Invalid filter 'string' definition with match phrase");
    l_match.assign (*l_defn_iter);
    ++l_defn_iter;
    if (l_defn_iter == l_defn_tokenizer.end () and l_defn_iter->empty ())
    {
      // Search string type.
      Result.reset (new matcher_string_search (l_match));
    }
    else
    {
      std::string l_format (*l_defn_iter);
      int l_mode (0); // Default mode is 'first'
      ++l_defn_iter;
      if (l_defn_iter != l_defn_tokenizer.end () and l_defn_iter->empty ())
      {
        l_mode = helper__::convert_mode (*l_defn_iter);
      }
      Result.reset (new matcher_string (l_match, l_format, l_mode));
    }
  }
  break;
case 3:
   {
    // Have a regex matcher
    std::string l_match;
    ++l_defn_iter;
    COMPCHEM_ALWAYS (l_defn_iter != l_defn_tokenizer.end (), "Invalid filter 'regex' definition with match phrase");
    l_match.assign (*l_defn_iter);
    ++l_defn_iter;
    if (l_defn_iter == l_defn_tokenizer.end () and l_defn_iter->empty ())
    {
      // Search string type.
      Result.reset (new matcher_regex_search (l_match));
    }
    else
    {
      std::string l_format (*l_defn_iter);
      int l_mode (0); // Default mode is 'first'
      ++l_defn_iter;
      if (l_defn_iter != l_defn_tokenizer.end () and l_defn_iter->empty ())
      {
        l_mode = helper__::convert_mode (*l_defn_iter);
      }
      Result.reset (new matcher_regex (l_match, l_format, l_mode));
    }
  }
  break;
default:
  COMPCHEM_ALWAYS (false, "Should never get here, invalid type in filter definition.");
  break;
}
COMPCHEM_REQUIRE (NULL != Result.get (), "Problem! Failed to create a new matcher object.");
return Result.release ();
!!!1309865.cpp!!!	matcher_filter(in a_filter : filter)
////////////////////////////////////
// Get the filter's text content.
std::stringstream l_content;
if (not a_filter.empty ())
{
  data_scheme::content_visitor l_visit (l_content);
  a_filter.visit (l_visit);
}
else
{
  // Try file
  COMPCHEM_ALWAYS (boost::filesystem::exists (a_filter.href ())
     , "A filter of type 'regex' must contain the definition or @href must point to a file with the definition");
  std::ifstream l_is (a_filter.href ().c_str ());
  std::copy (std::istream_iterator< char > (l_is), std::istream_iterator< char > (), std::ostream_iterator< char > (l_content));
}

COMPCHEM_ALWAYS (not l_content.eof ()
     , "A filter of type 'regex' must contain the definition or @href must point to a file with the definition");
//////////////////////
// Split the content into tokens and process
// Parse the content
std::string l_line;
std::getline (l_content, l_line);
m_main.reset (make_matcher (l_line));
if (not l_content.eof ())
{
  std::getline (l_content, l_line);
  m_start.reset (m_main.release ());
  m_main.reset (make_matcher (l_line));
}
if (not l_content.eof ())
{
  std::getline (l_content, l_line);
  m_main.reset (new matcher_pair (m_main.release (), make_matcher (l_line)));
}
COMPCHEM_ALWAYS (l_content.eof (), "Filter definition contains more than three lines.");
// Now call 'reset' to initialise m_current.
reset ();
!!!1538985.cpp!!!	output_string(out a_result : string) : int
// Ensure a_result is empty
COMPCHEM_REQUIRE (a_result.empty (), "Result string object should start empty.")
if (not m_start_result.empty ())
{
  a_result.assign (m_start_result);
}
else if (2 == m_main->mode)
{
  // 0 = first : one result, enclosing element not needed.
  // 1 = last : one result, enclosing element not needed
  // 2 = accum : multiple results, enclosing element needed
  a_result.assign ("<datum outcome=\"" + outcomes () + "\">");
}
const std::string l_tmp (m_result.str ());
if (not l_tmp.empty ())
{
  // Only in mode = 2 will m_result be 'closed'
  a_result.append (l_tmp);
  // 0 = first : no ending tag
  // 1 = last : no ending tag
  // 2 = accum : ending tag already appended
  if (2 != m_main->mode)
  {
    a_result.append ("</datum>");
  }
}
if (not m_start_result.empty () or 2 == m_main->mode)
{
  // Add closing tag because we created opening tag for !m_start_result.empty () or 2 == m_main->mode.
  a_result.append ("</datum>");
}
// Return unusable if m_result stream was empty or if a_result is still empty.
return (l_tmp.empty () or a_result.empty () ? CCHEM_SUPPLIER_UNUSABLE : CCHEM_SUPPLIER_SUCCESS);
!!!1539241.cpp!!!	process_part(in a_buffer : string) : int
int Result (CCHEM_SUPPLIER_SUCCESS);
std::string l_output;
// Process current matcher
Result = m_current->process_part (a_buffer, l_output);
if (not l_output.empty ())
{
  if (2 == m_current->mode) // Accumulate
  {
    // In accumulate mode, append data
    m_result << l_output << "</datum>";
  }
  else
  {
    // In other modes, reset data
    m_result.str (std::string());
    m_result << l_output;
  }
}
// If current matcher complete, test move to next matcher
if (CCHEM_SUPPLIER_COMPLETE == Result)
{
  if (m_current == m_start.get ())
  {
    // Current matcher was start. Save m_result into 
    // m_start_result (even if empty)
    m_start_result.assign (m_result.str ());
    m_result.str (std::string());
    m_current = m_main.get ();
    Result = CCHEM_SUPPLIER_SUCCESS;
  }
  else
  {
    m_current = NULL;
  }
}
return Result;
!!!1311273.cpp!!!	reset() : void
// Reset result stream.
m_result.str (std::string ());
// Reset cursor
if (NULL != m_start.get ())
{
  m_current = m_start.get ();
}
else
{
  m_current = m_main.get ();
}
