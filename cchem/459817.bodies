class program_py
!!!1468585.cpp!!!	pythonise() : void
/// Pythonise program
///
/// The pythonisation of the program C++ class.
program::compound_iterator (program::*program_begin_compound)() = &program::begin_compound;
program::compound_iterator (program::*program_end_compound)() = &program::end_compound;
program::mechanism_iterator (program::*program_begin_mechanism)() = &program::begin_mechanism;
program::mechanism_iterator (program::*program_end_mechanism)() = &program::end_mechanism;
program::project_iterator (program::*program_begin_project)() = &program::begin_project;
program::project_iterator (program::*program_end_project)() = &program::end_project;
program::worker_iterator (program::*program_begin_worker)() = &program::begin_worker;
program::worker_iterator (program::*program_end_worker)() = &program::end_worker;
    
boost::python::class_< program, boost::python::bases< basic_datum_py >, boost::noncopyable >("program",
        "A program of research is a broad category of interest. It is intended \n"
        "that the contents of a possible paper do not cross program boundaries, \n"
        "although several papers may be contained in a program.",
        boost::python::init< const std::string& >(
        "Create a program using the database filename given. This\n"
        "is the only public constructor in the data_scheme library.")
        )
 .def("add_compound", &program::add_compound, boost::python::return_internal_reference<>(),
        "Create and add a new compound child, using the passed argument as\n"
        "the compound's label.")
 .def("add_info", &program::add_info, boost::python::return_internal_reference<>(),
        "Create and add a new information child, using the passed argument as\n"
        "the info's name. This may only be done if no existing information\n"
        "object exists.")
 .def("add_mechanism", &program::add_mechanism, boost::python::return_internal_reference<>(),
        "Create and add a new mechanism child, using the passed argument as\n"
        "the mechanism's label.")
 .def("add_project", &program::add_project, boost::python::return_internal_reference<>(),
        "Create and add a new project child, using the passed argument as\n"
        "the project's label.")
 .def("add_project_src", &program::add_project_src, boost::python::return_internal_reference<>(),
        "Create and add a new project child, using the passed argument as\n"
        "the porject's database filename.")
 .def("add_worker", &program::add_worker, boost::python::return_internal_reference<>(),
        "Create and add a new worker child, using the passed argument as\n"
        "the worker's label.")
 .add_property("information", boost::python::make_function(&program_py::get_information_py, boost::python::return_internal_reference<>()),
        "The information object, may be None")
 .add_property("compounds", boost::python::range< boost::python::return_internal_reference<> >(program_begin_compound, program_end_compound),
        "The range of child compound objects, may be empty.")
 .add_property("mechanisms", boost::python::range< boost::python::return_internal_reference<> >(program_begin_mechanism, program_end_mechanism),
        "The range of child mechanism objects, may be empty.")
 .add_property("projects", boost::python::range< boost::python::return_internal_reference<> >(program_begin_project, program_end_project),
        "The range of child project objects, may be empty.")
 .add_property("workers", boost::python::range< boost::python::return_internal_reference<> >(program_begin_worker, program_end_worker),
        "The range of child worker objects, may only be empty for new program's.")
 .def ("write", &program::write, "Write the database")
  ;

