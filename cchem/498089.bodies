class xml_reader_test
!!!184745.cpp!!!	process_node(inout a_reader : xml_reader) : void
log () << WTCH << "Depth: [" << a_reader->depth () << "]\tType: [" << a_reader->node_type () << "]\tName: [" << a_reader->name () << "]\tIs Empty: [" << a_reader->empty () << "]\n";
log () << WTCH << "Prefix: [" << a_reader->prefix () << "]\tLocal name: [" << a_reader->local_name () << "]\n";
if (not a_reader->is_attribute ())
{
  if (a_reader->has_attribute ("PUBLIC"))
  {
    log () << WTCH << "PUBLIC: [" << a_reader->attribute ("PUBLIC") << "]\n";
  }
  if (a_reader->has_attribute ("SYSTEM"))
  {
    log () << WTCH << "SYSTEM: [" << a_reader->attribute ("PUBLIC") << "]\n";
  }
}
if (a_reader->node_type () == xmlreader::xml_reader::START_ELEMENT && a_reader->has_attributes ())
{
  static const std::string l_name ("chkcalc-config");
  static const std::string l_attr_name ("version");
  if (l_name == a_reader->name ())
  {
    if (a_reader->has_attribute (l_attr_name))
    {
      log () << WTCH << "Special attribute: " << l_attr_name << "=\"" << a_reader->attribute (l_attr_name) << "\"\n";
    }
  }
  log () << WTCH << "start attributes\n";
  a_reader->first_attribute ();
  do
  {
    process_node (a_reader);
  }
  while (a_reader->next_attribute ());
  a_reader->to_element ();
  log () << WTCH << "end attributes\n";
}
if (a_reader->node_type () == xmlreader::xml_reader::DOCTYPE && a_reader->has_attributes ())
{
  log () << WTCH << "start attributes\n";
  a_reader->first_attribute ();
  do
  {
    process_node (a_reader);
  }
  while (a_reader->next_attribute ());
  a_reader->to_element ();
  log () << WTCH << "end attributes\n";
}
if (a_reader->has_value ())
{
  log () << WTCH << "value = \"" << a_reader->value () << "\"\n";
}
!!!1591593.cpp!!!	main_test() : void
try
{
  // This initialize the library and check potential ABI mismatches
  // between the version it was compiled for and the actual shared
  // library used.
  LIBXML_TEST_VERSION

  for (std::vector < std::string >::const_iterator l_filename (m_files.begin ()); l_filename != m_files.end (); ++l_filename)
  {
    std::auto_ptr < xmlreader::xml_reader > l_reader;
    log () << COMM << "Test reading XML filename " << *l_filename << "\n";
    if (boost::filesystem::exists (*l_filename))
    {
      try
      {
        l_reader.reset (new xmlreader::xml_reader (*l_filename));
        while (l_reader->read ())
        {
          process_node (l_reader.get ());
        }
        if (not l_reader->is_doc_valid ())
        {
          log () << IFNO << "Error occurred while processing XML filename " << *l_filename << "\n";
        }
      }
      catch (const std::exception & err)
      {
        log () << EXCP << "Caught exception: " << err.what () << "\n";
      }
    }
    else
    {
      log () << EXCP << "ERROR, could not find input file \"" << *l_filename << "\"\n";
    }
    log () << COMM << "End reading XML filename" << *l_filename << "\n";
  }
}
catch (const std::exception & a_err)
{
  log () << "Caught exception: " << a_err.what () << "\n";

}

catch (...)
{
  log () << "Caught unknown exception\n";

}
!!!1591849.cpp!!!	register_options(inout a_optset : options_description) : void
a_optset.add_options ()("xmlfile,i", boost::program_options::value< std::vector< std::string > > (&m_files)->composing (), "A file to test using the xmlreader (may be used multiple times)");
  

