class program
!!!1425193.cpp!!!	add_child(in a_name : string, in a_label : string) : basic_datum
basic_datum * Result (NULL);
if (data_access::names::compound_name () == a_name)
{
  Result = &(add_compound (a_label));
}
else if (data_access::names::project_name () == a_name)
{
  Result = &(add_project (a_label));
}
else if (data_access::names::project_src_name () == a_name)
{
  Result = &(add_project_src (a_label));
}
else if (data_access::names::mechanism_name () == a_name)
{
  Result = &(add_mechanism (a_label));
}
else if (data_access::names::worker_name () == a_name)
{
  Result = &(add_worker (a_label));
}
else if (data_access::names::info_name () == a_name)
{
  Result = &(add_info (a_label));
}
else
{
  throw std::logic_error (serial_name() + " class has no child with name " + a_name);
}
return *Result;
!!!1424809.cpp!!!	add_compound(in a_label : string) : compound
m_catalog.push_back (new compound (*this, a_label));
// Before projects
if (not m_projects.empty ())
{
  insert_child (m_projects.front (), m_catalog.back ());
}
else
{
  append_child (m_catalog.back ());
}
return m_catalog.back ();

!!!1424425.cpp!!!	add_info(in a_label : string) : info
m_info.reset (new info (*this, a_label));
// First! (worker+,mechanism*,compound*,project*)
if (not m_staff.empty ())
{
  insert_child (m_staff.front (), *(m_info.get ()));
}
else if (not m_equipment.empty ())
{
  insert_child (m_equipment.front (), *(m_info.get ()));
}
else if (not m_catalog.empty ())
{
  insert_child (m_catalog.front (), *(m_info.get ()));
}
else if (not m_projects.empty ())
{
  insert_child (m_projects.front (), *(m_info.get ()));
}
else
{
  append_child (*(m_info.get ()));
}
return *(m_info.get ());
!!!1424681.cpp!!!	add_mechanism(in a_label : string) : mechanism
m_equipment.push_back (new mechanism (*this, a_label));
// Before (compound*,project*)
if (not m_catalog.empty ())
{
  insert_child (m_catalog.front (), m_equipment.back ());
}
else if (not m_projects.empty ())
{
  insert_child (m_projects.front (), m_equipment.back ());
}
else
{
  append_child (m_equipment.back ());
}
return m_equipment.back ();

!!!1424937.cpp!!!	add_project(in a_label : string) : project
m_projects.push_back (new project (*this, a_label, false));
// Always last
append_child (m_projects.back ());
return m_projects.back ();

!!!1425065.cpp!!!	add_project_src(in a_label : string) : project
m_projects.push_back (new project (*this, a_label, true));
// Always last
append_child (m_projects.back ());
return m_projects.back ();
!!!1424553.cpp!!!	add_worker(in a_label : string) : worker
m_staff.push_back (new worker (*this, a_label));
// Before mechanism*,compound*,project*
if (not m_equipment.empty ())
{
  insert_child (m_equipment.front (), m_staff.back ());
}
else if (not m_catalog.empty ())
{
  insert_child (m_catalog.front (), m_staff.back ());
}
else if (not m_projects.empty ())
{
  insert_child (m_projects.front (), m_staff.back ());
}
else
{
  append_child (m_staff.back ());
}
return m_staff.back ();
!!!1417513.cpp!!!	find_compound(in a_label : string) : compound_iterator
return std::find_if (m_catalog.begin (), m_catalog.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&compound::label, _1), a_label));
!!!1419305.cpp!!!	find_compound(in a_label : string) : const_compound_iterator
return std::find_if (m_catalog.begin (), m_catalog.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&compound::label, _1), a_label));
!!!1138473.cpp!!!	find_mechanism(in a_label : string) : mechanism_iterator
return std::find_if (m_equipment.begin (), m_equipment.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&mechanism::label, _1), a_label));
!!!1419433.cpp!!!	find_mechanism(in a_label : string) : const_mechanism_iterator
return std::find_if (m_equipment.begin (), m_equipment.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&mechanism::label, _1), a_label));
!!!1138345.cpp!!!	find_project(in a_label : string) : project_iterator
return std::find_if (m_projects.begin (), m_projects.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&project::label, _1), a_label));
!!!1419561.cpp!!!	find_project(in a_label : string) : const_project_iterator
return std::find_if (m_projects.begin (), m_projects.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&project::label, _1), a_label));
!!!1138729.cpp!!!	find_worker(in a_label : string) : worker_iterator
return std::find_if (m_staff.begin (), m_staff.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&worker::label, _1), a_label));
!!!1419689.cpp!!!	find_worker(in a_label : string) : const_worker_iterator
return std::find_if (m_staff.begin (), m_staff.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&worker::label, _1), a_label));
!!!1557545.cpp!!!	target_project() : project_iterator
return std::find_if (m_projects.begin (), m_projects.end (), boost::bind (std::equal_to< std::string >(), boost::bind (&project::label, _1), data_scheme_helper::helper ().target_project ()));
!!!1449385.cpp!!!	write() : void
COMPCHEM_CHECK (m_document->is_open (), "Program objects should always be open.");
m_document->write ();
