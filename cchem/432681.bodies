class basic_datum
!!!1669033.cpp!!!	add_comment_swallow(inout a_value : string) : basic_datum
m_base_elements.push_back (new comment (*this, a_value));
m_children.push_back (&m_base_elements.back ());
return m_base_elements.back ();
!!!1427241.cpp!!!	add_pi_swallow(in a_name : string, inout a_value : string) : basic_datum
m_base_elements.push_back (new processing_instruction (*this, a_name, a_value));
m_children.push_back (&m_base_elements.back ());
return m_base_elements.back ();
!!!1668905.cpp!!!	add_text_swallow(in a_value : string) : basic_datum
m_base_elements.push_back (new text (*this, a_value));
m_children.push_back (&m_base_elements.back ());
return m_base_elements.back ();
!!!1397929.cpp!!!	remove(inout a_item : iterator) : void
bool l_isfound (false);
for (boost::ptr_list< basic_text >::iterator a_item2 (m_base_elements.begin ()); m_base_elements.end () != a_item2; ++a_item2)
{
  if (&(*a_item2) == *a_item)
  {
    m_base_elements.erase (a_item2);
    l_isfound = true;
    break;
  }
}
if (not l_isfound)
{
  virt_remove_child (*a_item);
}
// Remove from child list
erase (a_item);
!!!1133481.cpp!!!	set_text(in a_str : string) : void
// We replace the text of the first 'text' object and delete all other 'text' objects
boost::ptr_list < basic_text >::iterator l_i (m_base_elements.begin ());
// Find first text element
while (m_base_elements.end () != l_i)
{
  if (l_i->serial_name () == data_access::names::text_type ())
  {
    // Capture first text element.
    l_i->the_content = a_str;
  }
}
// If a text element was found then l_i is not end()
if (m_base_elements.end () != l_i)
{
  // Remove any other text elements
  boost::ptr_list < basic_text >::iterator l_j (l_i);	// Marker: one-before-delete 
  ++l_i;
  while (m_base_elements.end () != l_i)
  {
    if (l_i->serial_name () == data_access::names::text_type ())
    {
      // Remove from m_children
      m_children.remove (&(*l_i));
      // Erase from m_base_elements.
      m_base_elements.erase (l_i);
      // Move l_i back to one-before-deleted object
      l_i = l_j;
    }
    else
    {
      // Not text, increment marker
      ++l_j;
    }
    ++l_i;
  }
}
else
{
  // No previous text
  add_text (a_str);
}
