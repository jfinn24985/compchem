class filesystem
!!!1182761.cpp!!!	standardize(in a_path : path) : path
boost::filesystem::path Result (a_path);
if (not Result.is_complete ())
{
  Result = boost::filesystem::initial_path () / Result;
}
Result.normalize ();
return Result;
!!!1178025.cpp!!!	relative_path(in a_base : path, in a_leafer : path) : path
// Ensure that starting paths are complete
boost::filesystem::path l_base (standardize (a_base));
boost::filesystem::path l_leaf (standardize (a_leafer));
boost::filesystem::path Result;
boost::filesystem::path::iterator l_lhs (l_base.begin ());
boost::filesystem::path::iterator l_rhs (l_leaf.begin ());
// Iterate along a_base and a_leafer for first mismatch.
if (*l_lhs != *l_rhs)
{ // No common base, just return a_leafer
  Result = l_leaf;
}
else
{
  for (++l_rhs, ++l_lhs; // Iterate to first mismatch.
	l_lhs != l_base.end () and l_rhs != l_leaf.end () and (*l_lhs) == (*l_rhs);
	++l_rhs, ++l_lhs); // Do nothing in loop.
  if (l_lhs != l_base.end ())
  { // Need to add "parent dirs" until we reach end
    for (; l_lhs != l_base.end (); ++l_lhs)
    {
      Result /= "..";
    }
  }
  if (l_lhs == l_base.end ())
  { // Now everything from l_rhs is in path.
    for (; l_rhs != l_leaf.end (); ++l_rhs)
    {
      Result /= *l_rhs;
    }
  }
}
return Result;
